------------------------------------------
        PTO: PHP template object
------------------------------------------

Yo Queria tener un sistema de plantilla tan bueno como smarty, tan liviano como
Savant y que hiciera un buen manejo de la cache como drupal (304 status). Que pudiera guardar
el contenido de la cache minificado y comprimido para disminuir el I/0 y que pudiera enviar el
contenido comprimido al cliente para disminuir la carga de la red y el trabajo
hecho por el servidor cuando se aplican filtros como: AddOutputFilterByType DEFLATE text/html text/xml
Que ademas pudiera guardar parte de los archivos compilados para ser utilizados como nuevos archivos
php a ejecutar.

1. Las plantillas dinamicas son archivos cuya extension .tpl.php

2. Se permiten plantillas cuya extension es .tpl el cual se interpreta como
   archivo estaticos

3. Si se configura un directorio para guardar la cache las plantillas son
   automicamente guardadas con la extesion .tpl, un .tpl.php es guardado
   si la plantilla contiene tag <nocache></nocache>
4. El sistema de plantilla esta en la forma base que consume la menor cantidad de
   recursos posible, si usted quiere mas herede la clase
5. Una plantilla padre no puede renderizar una plantilla hija dentro de un tag nocache si esta tiene
   a su vez tag nocache ejemplo:
   <nocache><?php $this->test->render('template'); ?></nocache>



                  -----------------------------
                          RECURSOS
                  -----------------------------
1. Revisar documento para cachear contenido:
   http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9
   http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.1
   http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.4

2. DRUPAL: include/bootstrap.inc drupal_serve_page_from_cache

3. Smarty

4. Savant

http://www.w3.org/Protocols/rfc2616/rfc2616-sec1.html
http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13
http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.11
http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9

http://www.mnot.net/cache_docs/
http://www.jonasjohn.de/snippets/php/caching.htm
http://www.mnot.net/blog/2005/11/26/caching
http://www.xml.com/pub/a/2006/02/01/doing-http-caching-right-introducing-httplib2.html?page=1
http://www.mnot.net/blog/2007/08/07/etags


Caching would be useless if it did not significantly improve performance.
The goal of caching in HTTP/1.1 is to eliminate the need to send requests in many cases,
and to eliminate the need to send full responses in many other cases. The former reduces
the number of network round-trips required for many operations; we use an "expiration"
mechanism for this purpose (see section 13.2). The latter reduces network bandwidth
requirements; we use a "validation" mechanism for this purpose (see section 13.3).

13.2 Expiration Model

If an origin server wishes to force a semantically transparent cache to validate every request,
it MAY assign an explicit expiration time in the past. This means that the response is always stale,
and so the cache SHOULD validate it before using it for subsequent requests.
See section 14.9.4 for a more restrictive way to force revalidation.

If an origin server wishes to force any HTTP/1.1 cache,
no matter how it is configured, to validate every request,
it SHOULD use the "must- revalidate" cache-control directive (see section 14.9).

Servers specify explicit expiration times using either the Expires header,
or the max-age directive of the Cache-Control header.

An expiration time cannot be used to force a user agent to refresh its display
or reload a resource; its semantics apply only to caching mechanisms, and
such mechanisms need only check a resource's expiration status when a new
request for that resource is initiated. See section 13.13 for an explanation of
the difference between caches and history mechanisms.